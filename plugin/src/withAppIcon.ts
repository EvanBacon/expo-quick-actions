import type { ExpoConfig } from "@expo/config";
import { generateImageAsync } from "@expo/image-utils";
import {
  type ConfigPlugin,
  IOSConfig,
  withDangerousMod,
  withInfoPlist,
  withXcodeProject,
  XcodeProject,
} from "@expo/config-plugins";
import fs from "fs";
import path from "path";
// @ts-ignore
import pbxFile from "xcode/lib/pbxFile";
import { withAndroidDynamicAppIcons } from "./withAndroidDynamicAppIcon";
import { withIosIconImageAsset } from "./withIosImageAssets";

/** The default icon folder name to export to */
const ICON_FOLDER_NAME = "DynamicAppIcons";

/**
 * The default icon dimensions to export.
 *
 * @see https://developer.apple.com/design/human-interface-guidelines/app-icons#iOS-iPadOS-app-icon-sizes
 */
const ICON_DIMENSIONS: IconDimensions[] = [
  // iPhone, iPad, MacOS, ...
  { scale: 2, size: 60 },
  { scale: 3, size: 60 },
  // iPad only
  { scale: 2, size: 60, width: 152, height: 152, target: "ipad" },
  { scale: 3, size: 60, width: 167, height: 167, target: "ipad" },
];

type IconDimensions = {
  /** The scale of the icon itself, affets file name and width/height when omitted. */
  scale: number;
  /** Both width and height of the icon, affects file name only. */
  size: number;
  /** The width, in pixels, of the icon. Generated from `size` + `scale` when omitted */
  width?: number;
  /** The height, in pixels, of the icon. Generated from `size` + `scale` when omitted */
  height?: number;
  /** Special target of the icon dimension, if any */
  target?: null | "ipad";
};

type IconSet = Record<string, IconSetProps>;
type IconSetProps = { image: string; prerendered?: boolean };

type Props = {
  icons: Record<string, { image: string; prerendered?: boolean }>;
  dimensions: Required<IconDimensions>[];
};

const withDynamicIcon: ConfigPlugin<string[] | IconSet | void> = (
  config,
  props = {}
) => {
  const icons = resolveIcons(props);

  // TODO: More sensible android options and some way to add platform specific icons.
  withAndroidDynamicAppIcons(config, {
    icons: Object.fromEntries(
      Object.entries(icons).map(([key, value]) => [
        // Must start with letter on Android.
        `expo_ic_${key}`,
        value.image,
      ])
    ),
  });

  for (const [key, value] of Object.entries(icons)) {
    config = withIosIconImageAsset(config, { name: key, icon: value.image });
  }

  config = withIconXcodeProject(config, Object.keys(icons));

  let hasWritten = false;
  const writeGeneratedContents = async () => {
    if (hasWritten) {
      return;
    }
    hasWritten = true;
    // Generate a TS file to export the icon names
    const typesFile = path.join(
      __dirname,
      "../../",
      // path.dirname(require.resolve("expo-quick-actions/package.json")),
      "icon/types.ts"
    );
    // TODO: Remove
    console.log(typesFile);

    const altIcons = Object.keys(icons).map((id) => ({
      id,
      src: { ios: getIconName(id, { size: 60 }), android: `expo_ic_${id}` },
    }));

    await fs.promises.writeFile(
      typesFile,
      `
// Generated by \`npx expo prebuild\`

export const ICONS = [
{
id: undefined,
src: { uri: process.env.EXPO_OS === 'ios' ? "AppIcon60x60" : "ic_launcher" },
},
${altIcons
  .map(
    ({ id, src }) =>
      `{
    id: ${JSON.stringify(id)},
    src: { uri: process.env.EXPO_OS === 'ios' ? "${src.ios}" : "${
        src.android
      }" },
}`
  )
  .join(",\n")}

] as const;

        `
    );
  };

  withDangerousMod(config, [
    "ios",
    async (config) => {
      await writeGeneratedContents();
      return config;
    },
  ]);
  withDangerousMod(config, [
    "android",
    async (config) => {
      await writeGeneratedContents();
      return config;
    },
  ]);

  return config;
};

const withIconXcodeProject: ConfigPlugin<string[]> = (config, icons) => {
  return withXcodeProject(config, async (config) => {
    // 1. Set the build settings for the main target

    const [, applicationTarget] = XcodeProject.findFirstNativeTarget(
      config.modResults
    );
    const buildConfigurations = XcodeProject.getBuildConfigurationsForListId(
      config.modResults,
      applicationTarget.buildConfigurationList
    );

    const iconNames = icons.join(" ");

    for (const [, xcBuildConfiguration] of buildConfigurations) {
      xcBuildConfiguration.buildSettings.ASSETCATALOG_COMPILER_INCLUDE_ALL_APPICON_ASSETS =
        "YES";
      xcBuildConfiguration.buildSettings.ASSETCATALOG_COMPILER_ALTERNATE_APPICON_NAMES =
        iconNames;
    }

    return config;
  });
};

/** Resolve and sanitize the icon set from config plugin props. */
function resolveIcons(props: string[] | IconSet | void): Props["icons"] {
  let icons: Props["icons"] = {};

  if (Array.isArray(props)) {
    icons = props.reduce(
      (prev, curr, i) => ({ ...prev, [i]: { image: curr } }),
      {}
    );
  } else if (props) {
    icons = props;
  }

  return icons;
}

/** Resolve the required icon dimension/target based on the app config. */
function resolveIconDimensions(config: ExpoConfig): Required<IconDimensions>[] {
  const targets: NonNullable<IconDimensions["target"]>[] = [];

  if (config.ios?.supportsTablet) {
    targets.push("ipad");
  }

  return ICON_DIMENSIONS.filter(
    ({ target }) => !target || targets.includes(target)
  ).map((dimension) => ({
    ...dimension,
    target: dimension.target ?? null,
    width: dimension.width ?? dimension.size * dimension.scale,
    height: dimension.height ?? dimension.size * dimension.scale,
  }));
}

/** Get the icon name, used to refer to the icon from within the plist */
function getIconName(
  name: string,
  dimension: Pick<Props["dimensions"][0], "size">
) {
  return `${name}-Icon-${dimension.size}x${dimension.size}`;
}

/** Get the full icon file name, including scale and possible target, used to write each exported icon to */
function getIconFileName(name: string, dimension: Props["dimensions"][0]) {
  const target = dimension.target ? `~${dimension.target}` : "";
  return `${getIconName(name, dimension)}@${dimension.scale}x${target}.png`;
}

/** Iterate all combinations of icons and dimensions to export */
async function iterateIconsAndDimensionsAsync(
  { icons, dimensions }: Props,
  callback: (
    iconKey: string,
    iconAndDimension: {
      icon: Props["icons"][string];
      dimension: Props["dimensions"][0];
    }
  ) => Promise<void>
) {
  for (const [iconKey, icon] of Object.entries(icons)) {
    for (const dimension of dimensions) {
      await callback(iconKey, { icon, dimension });
    }
  }
}

export default withDynamicIcon;
