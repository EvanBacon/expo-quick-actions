"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_plugins_1 = require("@expo/config-plugins");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const withAndroidDynamicAppIcon_1 = require("./withAndroidDynamicAppIcon");
const withIosImageAssets_1 = require("./withIosImageAssets");
/** The default icon folder name to export to */
const ICON_FOLDER_NAME = "DynamicAppIcons";
/**
 * The default icon dimensions to export.
 *
 * @see https://developer.apple.com/design/human-interface-guidelines/app-icons#iOS-iPadOS-app-icon-sizes
 */
const ICON_DIMENSIONS = [
    // iPhone, iPad, MacOS, ...
    { scale: 2, size: 60 },
    { scale: 3, size: 60 },
    // iPad only
    { scale: 2, size: 60, width: 152, height: 152, target: "ipad" },
    { scale: 3, size: 60, width: 167, height: 167, target: "ipad" },
];
const withDynamicIcon = (config, props = {}) => {
    const icons = resolveIcons(props);
    // TODO: More sensible android options and some way to add platform specific icons.
    (0, withAndroidDynamicAppIcon_1.withAndroidDynamicAppIcons)(config, {
        icons: Object.fromEntries(Object.entries(icons).map(([key, value]) => [
            // Must start with letter on Android.
            `expo_ic_${key}`,
            value.image,
        ])),
    });
    for (const [key, value] of Object.entries(icons)) {
        config = (0, withIosImageAssets_1.withIosIconImageAsset)(config, { name: key, icon: value.image });
    }
    config = withIconXcodeProject(config, Object.keys(icons));
    let hasWritten = false;
    const writeGeneratedContents = async () => {
        if (hasWritten) {
            return;
        }
        hasWritten = true;
        // Generate a TS file to export the icon names
        const typesFile = path_1.default.join(__dirname, "../../", 
        // path.dirname(require.resolve("expo-quick-actions/package.json")),
        "icon/types.ts");
        // TODO: Remove
        console.log(typesFile);
        const altIcons = Object.keys(icons).map((id) => ({
            id,
            src: { ios: getIconName(id, { size: 60 }), android: `expo_ic_${id}` },
        }));
        await fs_1.default.promises.writeFile(typesFile, `
// Generated by \`npx expo prebuild\`

export const ICONS = [
{
id: undefined,
src: { uri: process.env.EXPO_OS === 'ios' ? "AppIcon60x60" : "ic_launcher" },
},
${altIcons
            .map(({ id, src }) => `{
    id: ${JSON.stringify(id)},
    src: { uri: process.env.EXPO_OS === 'ios' ? "${src.ios}" : "${src.android}" },
}`)
            .join(",\n")}

] as const;

        `);
    };
    (0, config_plugins_1.withDangerousMod)(config, [
        "ios",
        async (config) => {
            await writeGeneratedContents();
            return config;
        },
    ]);
    (0, config_plugins_1.withDangerousMod)(config, [
        "android",
        async (config) => {
            await writeGeneratedContents();
            return config;
        },
    ]);
    return config;
};
const withIconXcodeProject = (config, icons) => {
    return (0, config_plugins_1.withXcodeProject)(config, async (config) => {
        // 1. Set the build settings for the main target
        const [, applicationTarget] = config_plugins_1.XcodeProject.findFirstNativeTarget(config.modResults);
        const buildConfigurations = config_plugins_1.XcodeProject.getBuildConfigurationsForListId(config.modResults, applicationTarget.buildConfigurationList);
        const iconNames = icons.join(" ");
        for (const [, xcBuildConfiguration] of buildConfigurations) {
            xcBuildConfiguration.buildSettings.ASSETCATALOG_COMPILER_INCLUDE_ALL_APPICON_ASSETS =
                "YES";
            xcBuildConfiguration.buildSettings.ASSETCATALOG_COMPILER_ALTERNATE_APPICON_NAMES =
                iconNames;
        }
        return config;
    });
};
/** Resolve and sanitize the icon set from config plugin props. */
function resolveIcons(props) {
    let icons = {};
    if (Array.isArray(props)) {
        icons = props.reduce((prev, curr, i) => ({ ...prev, [i]: { image: curr } }), {});
    }
    else if (props) {
        icons = props;
    }
    return icons;
}
/** Resolve the required icon dimension/target based on the app config. */
function resolveIconDimensions(config) {
    const targets = [];
    if (config.ios?.supportsTablet) {
        targets.push("ipad");
    }
    return ICON_DIMENSIONS.filter(({ target }) => !target || targets.includes(target)).map((dimension) => ({
        ...dimension,
        target: dimension.target ?? null,
        width: dimension.width ?? dimension.size * dimension.scale,
        height: dimension.height ?? dimension.size * dimension.scale,
    }));
}
/** Get the icon name, used to refer to the icon from within the plist */
function getIconName(name, dimension) {
    return `${name}-Icon-${dimension.size}x${dimension.size}`;
}
/** Get the full icon file name, including scale and possible target, used to write each exported icon to */
function getIconFileName(name, dimension) {
    const target = dimension.target ? `~${dimension.target}` : "";
    return `${getIconName(name, dimension)}@${dimension.scale}x${target}.png`;
}
/** Iterate all combinations of icons and dimensions to export */
async function iterateIconsAndDimensionsAsync({ icons, dimensions }, callback) {
    for (const [iconKey, icon] of Object.entries(icons)) {
        for (const dimension of dimensions) {
            await callback(iconKey, { icon, dimension });
        }
    }
}
exports.default = withDynamicIcon;
